from __future__ import print_function

import asyncio
import math
import random
import os
from collections import defaultdict
from xml.etree import cElementTree as ET
import aiohttp
import async_timeout
import warnings


class Rule34Post:
    """
    The data structure for images on rule34. By default, all items are none,
    they will only be something else if rule34.xxx specifies a value.
    if ``initialised`` is False, that means somehow this object wasn't initialised properly, and you should discard it
    """
    initialised = False  # If this is false, the post data isn't complete for whatever reason, dont use it

    # The image's data
    height = None  # Image dimension height
    width = None  # Image dimension width
    score = None  # The image's user determined rating
    file_url = None  # The image URL
    id = None # The id generated by rule34 for the image
    tags = None # All the tags associated with this image
    parent_id = None  # If this post is a child, this will show the ID of its parent
    has_children = None  # Is this post a parent?
    has_comments = None  # Are there comments on this post?
    has_notes = None  # Are there notes on this post?
    created_at = None  # When the post was posted, funnily enough
    change = None  # Not sure what this is used for, but all posts have it. If you know, leave an issue telling me
    md5 = None  # The MD5 hash of the post, i have no idea why its necessary to expose, but rule34.xxx generates it
    creator_ID = None  # The post author's ID
    rating = None  # The rating of the post, pretty much always "e", ie Explicit
    status = None # Not sure what this is used for, but all posts have it. If you know, leave an issue telling me
    source = None # The source of the image, if listed

    # SAMPLE VERSION - These are smaller images, saving some data, if necessary
    sample_url = None  # Sample Image URL
    sample_height = None  # Sample image dimension height
    sample_width = None  # Sample image dimension width

    # PREVIEW VERSION - A TINY version of the image, suitable for thumbnails
    preview_url = None  # Preview image URL
    preview_height = None  # Preview image height
    preview_width = None  # Preview image width


    def parse(self, post):
        """Processes the data returned by rule34 into a more useful object"""
        # If for whatever reason an attribute isn't in the data returned by r34, we set it to None

        self.height = int(post['@height']) if '@height' in post else None
        self.width = int(post['@width']) if '@width' in post else None
        self.score = int(post['@score']) if '@score' in post else None
        self.file_url = str(post['@file_url']) if '@file_url' in post else None
        self.id = str(post['@id']) if '@id' in post else None
        self.tags = post['@tags'].strip().split(" ") if '@tags' in post else None
        self.parent_id = int(post['@parent_ID']) if '@parentID' in post else None

        try:
            self.has_children = False if post['@has_children'] == "false" else True
        except KeyError:
            self.has_children = None

        self.has_comments = False if post['@has_comments'] == "false" else True
        self.has_notes = False if post['@has_notes'] == "false" else True
        self.created_at = str(post['@created_at']) if '@created_at' in post else None
        self.change = str(post['@change']) if '@change' in post else None
        self.md5 = str(post['@md5']) if '@md5' in post else None
        self.creator_ID = int(post['@creator_id']) if '@creator_id' in post else None
        self.rating = str(post['@rating']) if '@rating' in post else None
        self.status = str(post['@status']) if '@status' in post else None
        self.source = str(post['@source']) if '@source' in post else None

        # SAMPLE VERSION - These are smaller images, saving some data, if necessary
        self.sample_url = str(post['@sample_url']) if '@sample_url' in post else None
        self.sample_height = int(post['@sample_height']) if '@sample_height' in post else None
        self.sample_width = int(post['@sample_width']) if '@sample_width' in post else None

        # PREVIEW VERSION - A TINY version of the image, suitable for thumbnails
        self.preview_url = str(post['@preview_url']) if '@preview_url' in post else None
        self.preview_height = int(post['@preview_height']) if '@preview_height' in post else None
        self.preview_width = int(post['@preview_width']) if '@preview_width' in post else None

        self.initialised = True


class Rule34Error(Exception):  # pragma: no cover
    """Rule34 rejected you"""
    def __init__(self, message, *args):
        self.message = message
        super(Rule34Error, self).__init__(message, *args)


class RequestRejected(Exception):  # pragma: no cover
    """The Rule34 API wrapper rejected your request"""
    def __init__(self, message, *args):
        self.message = message
        super(RequestRejected, self).__init__(message, *args)


class Rule34:
    def __init__(self, loop, timeout=10):
        """
        :param loop: the event loop
        :param timeout: how long requests are allowed to run until timing out
        """
        self.session = aiohttp.ClientSession(loop=loop)
        self.timeout = timeout
        self.loop = loop

    def session(self):
        return self.session

    def ParseXML(self, rawXML):
        """Parses entities as well as attributes following this XML-to-JSON "specification"""

        if "Search error: API limited due to abuse" in str(rawXML.items()):
            raise Rule34Error('Rule34 rejected your request due to "API abuse"')

        d = {rawXML.tag: {} if rawXML.attrib else None}
        children = list(rawXML)
        if children:
            dd = defaultdict(list)
            for dc in map(self.ParseXML, children):
                for k, v in dc.items():
                    dd[k].append(v)
            d = {rawXML.tag: {k: v[0] if len(v) == 1 else v for k, v in dd.items()}}
        if rawXML.attrib:
            d[rawXML.tag].update(('@' + k, v) for k, v in rawXML.attrib.items())
        if rawXML.text:
            text = rawXML.text.strip()
            if children or rawXML.attrib:
                if text:
                    d[rawXML.tag]['#text'] = text
            else:
                d[rawXML.tag] = text
        return d

    @staticmethod
    def urlGen(tags=None, limit=None, ID=None, PID=None, deleted=None, rating=None, **kwargs):
        """Generates a URL to access the api using your input:
        :param tags: str ||The tags to search for. Any tag combination that works on the web site will work here. This includes all the meta-tags
        :param limit: str ||How many posts you want to retrieve
        :param ID: int ||The post id.
        :param PID: int ||The page number.
        :param deleted: bool||If True, deleted posts will be included in the data
        :param rating: The rating of the images, defaults to explicit
        :param kwargs:
        :return: url string, or None
        All arguments that accept strings *can* accept int, but strings are recommended
        If none of these arguments are passed, None will be returned
        """
        URL = "https://rule34.xxx/index.php?page=dapi&s=post&q=index"
        if PID is not None:
            if PID > 2000:
                raise RequestRejected("Rule34 will reject PIDs over 2000")
            URL += "&pid={}".format(PID)
        if limit is not None:
            URL += "&limit={}".format(limit)
        if ID is not None:
            URL += "&id={}".format(ID)
        if tags is not None:
            tags = str(tags).replace(" ", "+")
            URL += "&tags={}".format(tags)
        if deleted:
            URL += "&deleted=show"
        if PID is not None or limit is not None or ID is not None or tags is not None:
            if ID is not None:
                return URL
            else:
                if rating:
                    return URL + "&rating:" + rating
                else:
                    return URL + "&rating:explicit"
        else:
            return None

    async def totalImages(self, tags):
        """Returns the total amount of images for the tag
        :param tags:
        :return: int
        """
        if self.session.closed:
            self.session = aiohttp.ClientSession(loop=self.loop)
        with async_timeout.timeout(10):
            url = self.urlGen(tags=tags, PID=0)
            async with self.session.get(url=url) as rawXML:
                rawXML = await rawXML.read()
                rawXML = ET.XML(rawXML)
                XML = self.ParseXML(rawXML)
            await self.session.close()
            return int(XML['posts']['@count'])
        return None

    async def getImages(self, tags, fuzzy=False, singlePage=True, randomPID=True, OverridePID=None, rating=None):
        """gatherers a list of image's and their respective data -- replacing getImageURLS
        :param tags: the tags you're searching
        :param fuzzy: enable or disable fuzzy search, default disabled
        :param singlePage: when enabled, limits the search to one page (100 images), default disabled
        :param randomPID: when enabled, a random pageID is used, if singlePage is disabled, this is disabled
        :param OverridePID: Allows you to specify a PID
        :param rating: The rating of the images, defaults to explicit
        :return: list
        """
        if self.session.closed:  # Verify we have an active session (avoids errors)
            self.session = aiohttp.ClientSession(loop=self.loop)
        if fuzzy:
            tags = tags.split(" ")
            for tag in tags:
                tag = tag + "~"
            temp = " "
            tags = temp.join(tags)
        if randomPID is True and singlePage is False:
            randomPID = False
        num = await self.totalImages(tags)

        if num != 0:
            if OverridePID is not None:
                if OverridePID >2000:
                    raise RequestRejected("Rule34 will reject PIDs over 2000")
                PID = OverridePID
            elif randomPID:
                maxPID = 2000
                if math.floor(num/100) < maxPID:
                    maxPID = math.floor(num/100)
                PID = random.randint(0, maxPID)
            else:
                PID = 0
            imgList = []
            XML = None
            t = True
            while t:
                tempURL = self.urlGen(tags=tags, PID=PID, rating=rating)
                with async_timeout.timeout(self.timeout):
                    if self.session.closed:
                        self.session = aiohttp.ClientSession(loop=self.loop)
                    async with self.session.get(url=tempURL) as XML:
                        XML = await XML.read()
                        XML = ET.XML(XML)
                        XML = self.ParseXML(XML)
                if XML is None:
                    return None
                if len(imgList) >= int(XML['posts']['@count']):  # "if we're out of images to process"
                    t = False  # "end the loop"
                else:
                    # if isinstance(XML['posts']['post'], dict):
                    #     # Data is in dict, aka one image
                    #     image = Rule34Post()  # create an image object
                    #     image.parse(XML['posts']['post'])  # parse data into object
                    #     imgList.append(image)  # add to image list
                    # else:
                    #     # Data is string, aka many images
                    for post in XML['posts']['post']:
                        image = Rule34Post()
                        image.parse(post)
                        imgList.append(image)
                if singlePage:
                    await self.session.close()
                    return imgList
                PID += 1
            await self.session.close()
            return imgList
        else:
            await self.session.close()
            return None

    async def getPostData(self, PostID):
        """Returns a dict with all the information available about the post
        :param PostID: The ID of the post
        :return: dict
        """

        if self.session.closed:
            self.session = aiohttp.ClientSession(loop=self.loop)
        url = self.urlGen(ID=str(PostID))
        XML =None
        with async_timeout.timeout(10):
            async with self.session.get(url=url) as XML:
                XML = await XML.read()
            await self.session.close()
            try:
                XML = self.ParseXML(ET.XML(XML))
                data = XML['posts']['post']
            except ValueError:
                return None
            return data
        return None
